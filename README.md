# ParallelFourierTransform
Учебный проект по реализации спектрального фильтра для сигналов с помощью дискретного преобразования Фурье и стандарта параллельного программирования OpenMP.

## Описание программы: 
### Общие слова и навигация по частям программы
Для демонстрации работы программы выбрана задача спектральной фильтрации оптического импульса. В контексте волоконно-лазерных систем часто используется нелинейное уравнение Шрёдингера (НУШ) или кубическое уравнение Гинзбурга-Ландау (УГЛ), стационарное решение которых, если оно существует, зачастую можно найти в форме гиперболического секанса. НУШ и УГЛ описывают динамику комплексной огибающей волнового пакета, составляющего оптический импульс. 
В качестве примера сигнала выбран диссипативный солитон, искажённый аддитивным белым равномерным шумом. С помощью параллельнной реализации преобразования дискретного Фурье осуществляется его спектральная фильтрация. В качестве стандарта для распараллеливания программ на языке C++ использзуется OpenMP.

В проекте используется множество функций, имеющих дело с итерациями. По возможности все они реализованы распараллельно, в том числе имеющие линейную сложность. Для того, чтобы это было целесообразно, пришлось реализовать свой клас `MyVector`, поскольку контейнер `std::vector` при создании объектов всегда инициализирует память значениями по умолчанию (а это уже должно иметь линейное время). Поскольку используются, как комплексные, так и вещественные числа, он является шаблонным. В этом же классе реализованы функции для работы с массивами (файловый ввод и вывод; инициализация значениями по умолчанию; получение массива абсолютных значений; поиск индекса максимального элемента и пр.)
Функции, связанные с примером применения программы (создание сигнала, его зашумление; создание массива независимых величин; вырезение пика из импульса с некоторой окрестностью), реализованы в пространстве имён `GridFunctions`. 
Функции, связанные с преобразованием Фурье (прямое и обратное преобразование; получение массива частот; сдвиг массива), реализованы в пространстве имён `FourierTransform`.

### Инициализация или простое заполнение массивов значениями 
Как оказалось, для задач, когда каждая итерация цикла имеет одинаковую трудоёмкость, лучше всего подходит директива `# pragma omp parallel for schedule(static)`. Использование же команд `dynamic` и `guided` приводит к замедлению, поскольку на распределение задач цикла по потокам тратятся лишние вычисления. 
Такой подход использовался в конструкторе копирования и операторе присваивания класса `MyVector`, в методе `MyVector::zeros(...)`, в методе `MyVector::abs()`, в функции `GridFunctions::linspace(...)`, в функции `GridFunctions::make_signal_noisy(...)` и в функции `FourierTransform::dft_shift(...)`.

### Вычисление сложных функций в итерациях цикла
В этом случае наиболее эффективной себя показала директива `# pragma omp parallel for schedule(dynamic)`. Это можно объяснить тем, что при выполнении итераций, они оказываются не одинаковыми по сложности. 
Такой подход использовался в функциях, вычисляющих на каждой итерации экспоненту от комплексного числа: `GridFunctions::pulse_envelope(...)`, `FourierTransform::dft(...)` и `FourierTransform::idft(...)`.

### Особенности 
1. Параллельное считывание из файла методом `MyVector::parallel_read_from_file(...)` реализовано путём условного разделения массива на несколько частей и считывания каждой из них из определённого места файла в параллельной секции `#pragma omp parallel`. При этом не удалось использовать функцию `private(input_file)`. Видимо у объектов этого класса отсутствует конструктор копирования, поэтому пришлось в каждом параллельном потоке создавать отдельный поток ввода через обычный конструктор, что времязатратно. Из-за этого эффективность распараллеливания относительно низкая и уменьшается с увеличением количества потоков.
2. Оператор сравнения `MyVector::operator==(...)` был реализован для отладки считывания массивов из файла и внутренних тестов. Для него использовалась редукция по оператору логического "и": `#pragma omp parallel for schedule(static) reduction(&&:is_similar)`.
3. Для параллельной реализации поиска индекса максимального элемента `MyVector::argmax()` можно бы было использовать цикл с декларированной операцией редукции, описанной на странице 180 [руководства](https://www.openmp.org/wp-content/uploads/OpenMP4.0.0.pdf). Но для этого бы пришлось использовать `std::tuple`, чтобы передавать не только индекс элемента, но и его значение, что накладно и может существенно зааметдлить реализацию. Поэтому был выбран более простой подход: массив был условно разделён на несколько частей и в каждом параллельном потоке находился индекс максимального элемента и записывался в разделяемый массив. После параллельной секции `#pragma omp parallel` из результатов работы всех потоков был выбран индекс наибольшего элемента.
4. Для **параллельной реализации алгоритма дискретного преобразования Фурье** использовалось умножение матрицы на вектор. Используется явное указание, что распараллеливается вложенный цикл глубины 2, и OpenMP корректно обрабатывает такой случай. При этом матрица не создавалась, как отдельный объект, а вложенный цикл устроен таким образом, чтобы минимизировать количество обращений к памяти: 
```c++
#pragma omp parallel for schedule(dynamic) collapse(2)
for (int n = 0; n < points_num; n++) {
  Complex val_n = func_vector[n];  // минимизируем обращения к памяти
  for (int k = 0; k < points_num; k++) {
    double current_frequency = (double)k * n / points_num;
    transform_result[k] += exp(-2.0i * M_PI * current_frequency) * val_n;
    }
}
```

## Анализ свойств параллельной реализации дискретного преобразования Фурье 
Для анализа свойств параллельной реализации были проведены замеры времени её выполнения для различного количества потоков. Каждое значение времени определялось, как среднее арифметическое из пяти результатов запусков программы. Вычисления производились на процессоре *12th Gen Intel(R) Core(TM) i5-12450H 2.00 GHz* с 8 ядрами, в качестве компилятора использовался MSVC со стандартными настройками.

![image_3](https://github.com/user-attachments/assets/f60462d5-e488-4f1c-8367-4be09e79337e)
![image_2](https://github.com/user-attachments/assets/5d44e4dc-80ed-4ae7-81d9-1b4881bb6ff1)
![image_1](https://github.com/user-attachments/assets/6ab64ab6-92e2-46d4-976c-1d99555469cc)

По представленным графикам можно сделать вывод о том, что реализация является хорошо масштабируемой, потому что эффективность медленно снижается с ростом количества параллельных потоков


## Визуализация результатов работы программы:
(для построения графиков необходимо загрузить бинарные файлы в [ноутбук](https://colab.research.google.com/drive/1-UlH4bmY1PnjkDwtWJfJXWtwqR4FPy5y?usp=sharing) и запустить его)

![filter_demo](https://github.com/user-attachments/assets/4f3e866b-9dd0-4d8b-b5cf-f951c34a2a51)
